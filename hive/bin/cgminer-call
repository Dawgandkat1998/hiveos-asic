#!/usr/bin/env bash


#
# Copyright (C) 2017  Hiveon Holding LTD
# Distributed under Business Source License 1.1
# License information can be found in the LICENSE.txt file or at https://github.com/minershive/hiveos-asic/blob/master/LICENSE.txt
#
# Linted by shellcheck 0.7.0
#


readonly script_mission='Client for ASICs: cgminer API prober'
readonly script_version='0.4.3'
readonly script_basename="${0##*/}"


# !!! bash strict mode, no unbound variables
set -o nounset


# functions

function echo_ok		{ echo -e "${LGRAY-}  ${BGREEN-}${*}${NOCOLOR-}"; }
function echo_action	{ echo -e "${LGRAY-}> ${WHITE-}${*}...${NOCOLOR-}"; }
function echo_info		{ echo -e "${LGRAY-}  ${NOCOLOR-}${*}"; }
function echo_warning	{ echo -e "${LGRAY-}? ${BYELLOW-}${*}${NOCOLOR-}"; }
function echo_debug		{ echo -e "${LGRAY-}  ${BPURPLE-}[DEBUG] ${*}${NOCOLOR-}"; } 1>&2
function echo_error		{ echo -e   "${RED-}! ${BRED-}${*}${NOCOLOR-}"; } 1>&2

function print_script_version {
	echo -e "${YELLOW-}${script_mission}, version ${script_version}${NOCOLOR-}"
	echo
} 1>&2

function print_script_usage {
	echo -e "Usage: ${CYAN-}$script_basename [host[:port]]${NOCOLOR-}"
	echo
	echo -e "    ${WHITE-}host${NOCOLOR-}  host name or IP address, default is $cgminer_host_DEFAULT"
	echo -e "    ${WHITE-}port${NOCOLOR-}  port number, default is $cgminer_port_DEFAULT"
	echo
	echo -e "All gathered information will be located at $base_DIR/"
	echo
} 1>&2

function parse_url {
	#
	# ad-hoc solution, would improve it later
	# https://stackoverflow.com/questions/6174220/parse-url-in-shell-script
	#

	# args
	local -r url="${1-}"

	# REs
	local -r url_RE='^(([[:alnum:]]+):\/\/)?(([[:alnum:]]+)@)?([^:^@\/]+)(:([[:digit:]]+))?(\/?[^:^@]?)$'

	# vars
	local host='' port=''

	# code
	if [[ -z "$url" ]]; then
		: ok
	elif [[ "$url" =~ $url_RE ]]; then
#		proto="${BASH_REMATCH[2]}"
#		user="${BASH_REMATCH[4]}"
		host="${BASH_REMATCH[5]}"
		port="${BASH_REMATCH[7]}"
#		path="${BASH_REMATCH[8]}"
#		echo "proto '$proto'"
#		echo "user '$user'"
#		echo "host '$host'"
#		echo "port '$port'"
#		echo "path '$path'"
	else
		echo_error "Invalid address '$url'"
		return 1
	fi

	[[ -n "$host" ]] && cgminer_host="$host" || cgminer_host="$cgminer_host_DEFAULT"
	[[ -n "$port" ]] && cgminer_port="$port" || cgminer_port="$cgminer_port_DEFAULT"
}

function make_and_send_tarball {
	# args
	local -r firmware_vendor="$1"
	local -r firmware_model="$2"
	local -r firmware_version="$3"

	# consts
	local -r message_script='/hive/bin/message'

	# vars
	local relative_path_for_tar tarball_name_raw tarball_name_sanitized

	# code
	tarball_name_raw="${base_DIR:?}/cgminer-api-data-${firmware_vendor}-${firmware_model}-${firmware_version}.tar.gz"
	tarball_name_sanitized="${tarball_name_raw//[:@ ]/-}" # anything else to replace?
	relative_path_for_tar="${firmware_vendor}/${firmware_model}/${firmware_version}/"

	echo_action "Preparing archive $tarball_name_sanitized"

	if tar czvf "${tarball_name_sanitized:?}" -C "${base_DIR:?}" "${relative_path_for_tar:?}" > /dev/null; then
		echo_ok 'Prepared OK'
		if [[ -x "$message_script" ]]; then
			# send this tar to the dashboard
			echo_action 'Sending it to your Hive dashboard'
			if "$message_script" file "$tarball_name_sanitized" --silent; then
				echo_ok 'Sent OK'
			fi
		else
			echo_warning "$message_script not found, cannot send the tarball to the Hive"
		fi
	fi
}


# global sources

# shellcheck disable=SC1091
[[ -s /hive/bin/colors ]] && source /hive/bin/colors


# global dictionaries

declare -r -a cgminer_commands_DICT=(
	'devs'
	'miner_conf' # S19
	'get_miner_conf'
	'pools'
	'stats'
	'summary'
	'system_info'
	'version'
	)


# global consts

# defaults
declare -r cgminer_host_DEFAULT='localhost'
declare -r -i cgminer_port_DEFAULT=4028
# paths & filenames
declare -r base_DIR="/tmp/$script_basename"
declare -r sanitize_DIR="${base_DIR}/sanitized-data"
declare -r raw_DIR="${base_DIR}/raw-data"
declare -r api_collection_filename='full-api-collection.json'


# global vars

declare cgminer_host
declare  -i cgminer_port
declare -i total_request_counter=0 answered_request_counter=0 command_supported_request_counter=0
declare this_command this_command_cmd this_command_log_raw_FILE this_command_log_sanitized_FILE
declare api_collection_FILE


# code

print_script_version

if ! parse_url "${1-}" || [[ "${1-}" == '--help' || "${1-}" == '-h' ]]; then
	print_script_usage
	exit 1
fi

mkdir -p -- "$raw_DIR" "$sanitize_DIR"

echo_action "Polling cgminer API at ${cgminer_host}:${cgminer_port}"

for this_command in "${cgminer_commands_DICT[@]}"; do

	this_command_cmd="{\"command\":\"$this_command\"}"
	this_command_log_raw_FILE="${raw_DIR}/${this_command}.json"
	this_command_log_sanitized_FILE="${sanitize_DIR}/${this_command}.json"

	echo_action "Sending command '$this_command'"

	if timeout nc "$cgminer_host" "$cgminer_port" <<< "$this_command_cmd" > "$this_command_log_raw_FILE" 2> /dev/null; then
		(( total_request_counter++ ))

		if [[ -s "$this_command_log_raw_FILE" ]]; then # we have received something
			(( answered_request_counter++ ))

			if ! tail -c 1 "$this_command_log_raw_FILE" | read -r _; then
				# a terminating newline doesn't exist
				echo_info "No newline terminator at the end, appending..."
				echo >> "$this_command_log_raw_FILE" # add a newline (actually it's for Gitlab to ease the file preview)
			fi

			if hash jq && ! jq_error="$( jq --exit-status 'empty' "$this_command_log_raw_FILE" 2>&1 )" && [[ -n "$jq_error" ]]; then
				# sanity check
				echo_warning "Invalid JSON in $this_command_log_raw_FILE ($jq_error)"
			fi

			# sanitizing
			tr -d '\0\n' < "$this_command_log_raw_FILE" | sed 's/}{/},{/' | jq --compact-output '.' > "$this_command_log_sanitized_FILE"

			# checking for invalid command
			if cgminer_status_msg="$( jq --raw-output '.STATUS[].Msg' "$this_command_log_sanitized_FILE" 2> /dev/null )"; then
				case "$cgminer_status_msg" in
					'Invalid command' | 'invalid cmd') # the former is Antminer's, the latter is Whatsminer's
						echo_info "Answer is '$cgminer_status_msg', saving skipped"
						rm -- "$this_command_log_raw_FILE" "$this_command_log_sanitized_FILE" # we don't need those anymore
					;;
					*)
						(( command_supported_request_counter++ ))
						echo_ok "Answer is '$cgminer_status_msg', saved to $this_command_log_raw_FILE"
					;;
				esac
			else
				echo_warning "No 'STATUS.Msg' key in the answer. Is it the cgminer? Saved to $this_command_log_raw_FILE, please take a look"
			fi

		elif [[ -f "$this_command_log_raw_FILE" ]]; then # empty file = empty answer
			echo_error 'Nothing received'
			rm -- "$this_command_log_raw_FILE"
		fi

	else
		echo_error 'Connection failed'
	fi

done

if (( command_supported_request_counter )); then
	echo_info "Done. $command_supported_request_counter supported commands, ${answered_request_counter} answered, ${total_request_counter} total"

	if hash jq; then
		api_collection_FILE="${base_DIR}/${api_collection_filename}"

		echo_action "Producing a consolidated $api_collection_FILE"

		# shellcheck disable=SC2016
		# bc we don't need to expand this
		collate_files_JQ='reduce inputs as $s ( .; ( .[ input_filename | gsub( ".*/|\\.json$"; "" ) ] ) += $s )'
		if jq --exit-status --null-input "$collate_files_JQ" "${sanitize_DIR}/"*.json > "$api_collection_FILE"; then
			echo_ok 'Produced OK'
			echo_action "Identifying firmware"

			# get firmware name
			get_name_JQ='[ .. | objects | with_entries(select(.key == "Type")) | select(. != {}) ] | unique | .[] | to_entries | .[].value'
			firmware_name="$( jq --exit-status --raw-output "$get_name_JQ" "$api_collection_FILE" 2> /dev/null )" ||
					echo_warning 'No ".Type" key found'

			# get firmware version
			get_version_JQ='[ .. | objects | with_entries(select(.key == "CompileTime")) | select(. != {}) ] | unique | .[] | to_entries | .[].value'
			firmware_version="$( jq --exit-status --raw-output "$get_version_JQ" "$api_collection_FILE" 2> /dev/null )" ||
					echo_warning 'No ".CompileTime" key found'

			# sanitize
			[[ -z "$firmware_name"		|| "$firmware_name"		== 'null' ]]	&& firmware_name='unknown_name' # fallback
			[[ -z "$firmware_version"	|| "$firmware_version"	== 'null' ]]	&& firmware_version='unknown_version' # fallback

			# parse the firmware name
			IFS=' ' read -r -a firmware_name_ARR <<< "$firmware_name"
			if (( ${#firmware_name_ARR[@]} > 1 )); then
				firmware_vendor="${firmware_name_ARR[0]}" # 1st word
				firmware_model="${firmware_name_ARR[*]:1}" # from 2nd word to the end
			else
				firmware_vendor="${firmware_name_ARR[*]}"
				firmware_model='unknown_model'
			fi

			echo_info "Vendor '$firmware_vendor', model '$firmware_model', date '$firmware_version'"

			# make a deep dir tree
			target_DIR="${base_DIR}/${firmware_vendor}/${firmware_model}/${firmware_version}"
			mkdir -p "${target_DIR:?}"

			# move relevant files
			mv -- "${api_collection_FILE:?}" "${target_DIR:?}/"
			mv -- "${raw_DIR:?}/"* "${target_DIR:?}/"

			echo_ok "Data saved to $target_DIR"

			make_and_send_tarball "$firmware_vendor" "$firmware_model" "$firmware_version"

			# cleanup
			rm -r -- "${sanitize_DIR:?}/" "${raw_DIR:?}/"
		else
			echo_error 'Something goes wrong'
		fi
		echo_info 'All done'
	else
		echo_warning 'jq not found, cannot do a deep firmware inspection'
	fi
else
	# cleanup
	rm -r -- "${sanitize_DIR:?}/" "${raw_DIR:?}/"
	echo_warning 'Totally failed, exiting'
fi
